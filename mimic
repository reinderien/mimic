#!/usr/bin/python2
# coding=utf-8


# Surrounding field for printing clarity
field = u'\u2591'


def get_homographs():
    """
    Use http://dev.networkerror.org/utf8/?start=0&end=255&cols=10&show_uni_hex=on
    with the stupid table width forced to auto.
    This dataset is for ASCII characters mapped to UTF-8 homographs (some approximate).
    Some of the entries are also selected from the results of search(), below.
    """
    return (
        u' \u00A0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F',
        u'!\uFF01\u01C3\u2D51\uFE15\uFE57',
        u'"\uFF02',
        u'#\uFF03\uFE5F',
        u'$\uFF04\uFE69',
        u'%\uFF05\u066A\u2052\uFE6A',
        u'&\uFF06\uFE60',
        u"'\uFF07\u02B9",
        u'(\uFF08\u27EE\uFE59',
        u')\uFF09\u27EF\uFE5A',
        u'*\uFF0A\u22C6\uFE61',
        u'+\uFF0B\u16ED\uFE62',
        u',\uFF0C\u02CF\u16E7\u201A',
        u'-\uFF0D\u02D7\u1680\u174D\u1806\u1C7C\u2212\u23AF\u23BC\u2574\u2CBB\u2CBB\u30FC\u3127\uFE63',
        u'.\uFF0E\u2024',
        u'/\uFF0F\u1735\u2044\u2215\u29F8\u2CC6\u3033',
        u'0\u1C50',
        u'1',
        u'2\u14BF',
        u'3\u01B7\u1883\u2128\u2CC4\u2CCC\u2CCD',
        u'4\u13CE',
        u'5',
        u'6\u13EE',
        u'7',
        u'8',
        u'9\u13ED',
        u':\uFF1A\u02D0\u02F8\u0589\u1361\u16EC\u1804\u1C7A\u205A\u2236\u2806\uFE13\uFE30\uFE55',
        u';\uFF1B\u037E\uFE14\uFE54',
        u'<\uFF1C\u02C2\u2039\u227A\u276E\u2D66\u3031\u3111\uFE64',
        u'=\uFF1D\u2550\u268C\u30A0\uFE66',
        u'>\uFF1E\u02C3\u203A\u227B\u276F\uFE65',
        u'?\uFF1F\uFE16\uFE56',
        u'@\uFF20\uFE6B',
        u'A\u0391\u0410\u13AA',
        u'B\u0392\u0412\u13F4\u15F7\u2C82',
        u'C\u03F9\u0421\u13DF\u216D\u2CA4',
        u'D\u13A0\u15EA\u216E',
        u'E\u0395\u0415\u13AC',
        u'F\u15B4',
        u'G\u050C\u13C0',
        u'H\u0397\u041D\u12D8\u13BB\u157C\u2C8E',
        u'I\u0399\u0406\u2160',
        u'J\u0408\u13AB\u148D',
        u'K\u039A\u039A\u13E6\u16D5\u212A\u2C94',
        u'L\u13DE\u14AA\u216C\u2CD0',
        u'M\u039C\u03FA\u041C\u13B7\u216F',
        u'N\u039D\u2C9A',
        u'O\u039F\u041E\u1C5B\u2C9E',
        u'P\u03A1\u0420\u13E2\u2CA2',
        u'Q\u051A\u10B3\u2D55',
        u'R\u13A1\u13D2\u1587',
        u'S\u0405\u10BD\u13DA',
        u'T\u03A4\u0422\u13A2',
        u'U',
        u'V\u13D9\u2164',
        u'W\u13B3\u13D4',
        u'X\u03A7\u0425\u2169\u2CAC',
        u'Y\u03A5\u2CA8',
        u'Z\u0396\u13C3',
        u'[\uFF3B',
        u'\\\uFF3C\u2216\u29F5\u29F9\u3035\uFE68',
        u']\uFF3D',
        u'^\uFF3E\u02C4\u02C6\u1DBA\u2303',
        u'_\uFF3F\u02CD\u268A\uFE58',
        u'`\uFF40\u02CB\u1FEF\u2035',
        u'a\u0251\u0430',
        u'b',
        u'c\u03F2\u0441\u217D',
        u'd\u0501\u217E',
        u'e\u0435\u1971',
        u'f',
        u'g\u0261',
        u'h\u04BB',
        u'i\u0456\u2170',
        u'j\u03F3\u0458',
        u'k',
        u'l\u217C',
        u'm\u217F',
        u'n\u1952',
        u'o\u03BF\u043E\u0CE6\u0D20\u0D66\u199E\u19D0\u2C9F',
        u'p\u0440\u2CA3',
        u'q',
        u'r',
        u's\u0455',
        u't',
        u'u\u1959\u222A',
        u'v\u1D20\u2174\u2228\u22C1',
        u'w\u1D21',
        u'x\u0445\u2179\u2CAD',
        u'y\u0443\u1EFF',
        u'z\u1901\u1D22',
        u'{\uFF5B\uFE5B',
        u'|\uFF5C\u01C0\u16C1\u239C\u239F\u23A2'
        + u'\u23A5\u23AA\u23AE\u2F01\u3021\u4E28\uFE31\uFE33\uFFE8',
        u'}\uFF5D\uFE5C',
        u'~\uFF5E\u02DC\u2053\u223C\u301C'
    )


def homographs_for_char(char):
    """
    :param char: The ASCII char to look up
    :return: A string of homographs for that char
    """
    index = ord(char) - ord(' ')
    return get_homographs()[index]


def has_homographs(char):
    """
    :param char: A character to check
    :return: Whether that character is printable ASCII (i.e. we have
    homographs for it)
    """
    return ord(' ') <= ord(char) <= ord('~')


def get_writer():
    """
    :return: A codec writer for stdout. Necessary for output piping to work.
    """
    from codecs import getwriter
    from sys import stdout
    return getwriter(stdout.encoding or 'utf-8')(stdout)


def listing():
    """
    Show a list of all known homographs
    """
    out = get_writer()
    for homs in get_homographs():
        for c in homs:
            out.write(field + c)
        out.write(field + '\n')


def explain(char):
    """
    Show an explanation of all known homographs for the given ASCII char
    :param char: An ASCII char to explain
    """
    if not has_homographs(char):
        print 'Must be ASCII'
        return

    try:
        import unicodedata
    except ImportError:
        print 'Install docutils.'
        return

    out = get_writer()

    out.write('Char\tPoint %20s Cat Name\n' % ('Normal'))

    for hg in homographs_for_char(char):
        norms = ''
        for form in ('NFC', 'NFKC', 'NFD', 'NFKD'):
            h = unicodedata.normalize(form, hg)
            if len(h) == 1 and has_homographs(h):
                if norms:
                    norms += ' '
                norms += form
        out.write(' %(field)c%(hg)c%(field)c\t'
                  'u%(point)04X %(norms)20s %(cat)3s %(name)s\n' % {
                      'field': field,
                      'hg': hg,
                      'point': ord(hg),
                      'norms': norms,
                      'cat': unicodedata.category(hg),
                      'name': unicodedata.name(hg, '<unnamed>')
                  })


def search():
    """
    (Not useful to the user) Troll the unicode DB for normalization matches, which are potentially homographs.
    """
    try:
        import unicodedata
    except ImportError:
        print 'Install docutils.'
        return

    out = get_writer()

    for point in xrange(ord('~')+1, 0x10000):
        u = unichr(point)
        for form in ('NFC', 'NFKC', 'NFD', 'NFKD'):
            h = unicodedata.normalize(form, u)
            if len(h) == 1 and ord(h) != ord(u) and has_homographs(h):
                out.write('%(ascii)c %(form)s->  %(hg)c\tu%(point)04X %(cat)s/%(name)s' % {
                    'ascii': h,
                    'form': form,
                    'hg': u,
                    'point': ord(u),
                    'cat': unicodedata.category(u),
                    'name': unicodedata.name(u, '<unnamed>')
                })
                break


def pipe(hardness):
    """
    Pipe from input to output, replacing chars with homographs
    End with ctrl+C or EOF
    :param hardness: Percent probability to replace a char
    """
    from random import random, randrange

    out = get_writer()

    # "for line in stdin" works for piped input but not keyboard input

    while True:
        try:
            line = raw_input()
        except EOFError:
            return
        for c in line:
            if random() < hardness/100 and has_homographs(c):
                hms = homographs_for_char(c)
                index = randrange(len(hms))
                c = hms[index]
            out.write(c)
        out.write('\n')


def parse():
    from optparse import OptionParser

    parser = OptionParser()
    parser.add_option('-m', '--me-harder', dest='chance', type='float', default=1,
                      help='replacement percent')
    parser.add_option('-e', '--explain', dest='char',
                      help="show a char's homographs")
    parser.add_option('-l', '--list', action='store_true',
                      help='show all homographs')
    return parser.parse_args()


def main():
    try:
        (options, args) = parse()
        if options.list:
            listing()
        elif options.char:
            explain(unicode(options.char[0], 'utf-8'))
        else:
            pipe(options.chance)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
